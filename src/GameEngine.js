// Reference path generated by VS Code for "Type definitions for Node.js" file
/// <reference path="../typings/node/node.d.ts"/>

// Node.js modules
var MapManager = require('./MapManager.js');
var GameModel  = require('./GameModel.js');
var GameView   = require('./GameView.js');
var commands   = require('./commands.js')
var async      = require('async');
var _          = require('lodash');
var r          = require('rethinkdb');

function GameEngine() {
  this.gameModel = undefined;
  this.gameView  = new GameView();

  this.connection      = null;
  this.pendingCommands = [];
}

GameEngine.prototype.initializeBindings = function () {
  var this_ge = this;
  
  // Add key events to the following:
  // -- Exit --
  this.gameView.bindKey(['escape', 'q', 'C-c'], function(ch, key) {
    return process.exit(0);
  });

  // -- Arrow keys --
  function process_arrow_key (ch, key) {
	var direction = key.name;
    if (this_ge.gameModel.canMovePlayer(direction)) {
      this_ge.pushCommand(new commands.MovePlayer(direction), function () {
        this_ge.render();
      });
    } else {
      this_ge.render();
    }
    
  };

  this.gameView.bindKey('left',  process_arrow_key);
  this.gameView.bindKey('right', process_arrow_key);
  this.gameView.bindKey('up',    process_arrow_key);
  this.gameView.bindKey('down',  process_arrow_key);
};

GameEngine.prototype.pushCommand = function (command, callback) {
  //this.pendingCommands.push(command);
  r.table('commands').insert([
    _.extend(command, {session: 1})
  ]).run(this.connection)
  .then(function(result) {
    callback();
  });
};

GameEngine.prototype.render = function () {
  var self = this;

  _.forEach(this.pendingCommands, function(command) {
    command.execute(self.gameModel); 
  });
  this.pendingCommands = [];

  this.gameView.refresh();
  MapManager.render(this.gameModel, this.gameView.getGameViewport(), this.gameView.getCanvas());
};

GameEngine.prototype.playLevel = function (level, callback) {
  var this_ge = this;
  var datacursor = null;

  var on_objective_ok = function () {
    this_ge.gameView.pushLine("Sys: One objective complete");
  };
  
  var on_game_over = function() {
    this_ge.gameView.pushLine("Sys: Game over, thanks for playing");
    
    datacursor.close();

    r.table('commands')
     .filter({"session": 1})
     .delete()
     .run(this_ge.connection)
     .then(function(result) {       
       callback(null, null);
     });
  };

  var on_ready = function () {
    this_ge.gameView.pushLine("Sys: Now playing " + level);
    this_ge.render();
    
    r.table('commands')
     .filter(r.row('session').eq(1))
     .run(this_ge.connection)
     .then(function(cursor) {
        cursor.toArray(function(err, result) {
          if (err) throw err;
          _.forEach(result, function(command) {
            this_ge.pendingCommands.push(commands.parse(command));
          });
          this_ge.render();
            
          r.table('commands')
           .filter(r.row('session').eq(1))
           .changes()
           .run(this_ge.connection)
           .then(function(cursor) {
             datacursor = cursor;
             cursor.each(function(err, row) {
               if (err) throw err;
               this_ge.pendingCommands.push(commands.parse(row['new_val']));
               this_ge.render();
             });
           });
        });
    });
  };

  var on_map_loaded = function (err, map) {
    MapManager.validate(map);
	    
    this_ge.gameModel = new GameModel ();

    this_ge.gameModel.on('ready', on_ready);
    this_ge.gameModel.on('objective-ok', on_objective_ok);
    this_ge.gameModel.on('game-over', on_game_over);
    
    r.table('commands')
     .filter({"session": 1})
     .delete()
     .run(this_ge.connection)
     .then(function(result) {
        this_ge.gameModel.initialize(map, MapManager.internalize(map));
      });
  }

  MapManager.load('level1.tmx', on_map_loaded);
};

GameEngine.prototype.run = function () {
  this.initializeBindings();
  
  var self = this;
  async.series([
    function (callback) {
      r.connect( {host: 'localhost', port: 28015}, function(err, conn) {
        if (err) throw err;
        self.connection = conn;
        callback(err, null);
      });
    },
    function (callback) {
      self.playLevel('level1', callback);
    },
    function (callback) {
      self.playLevel('level2', callback);
    }, 
  ], function (err, results) {
	
  });

};

module.exports = GameEngine;
