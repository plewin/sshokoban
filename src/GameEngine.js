// Reference path generated by VS Code for "Type definitions for Node.js" file
/// <reference path="../typings/node/node.d.ts"/>

// Node.js modules
var MapManager = require('./MapManager.js');
var blessed    = require('blessed');
var program    = blessed.program();
var async      = require('async'); 

// GameEngine object constructor
function GameEngine() {
  // Add a blessed screen object
  this.screen = blessed.screen({
    autoPadding: true,
    smartCSR: true
  });

  this.currentMap          = undefined;
  this.currentSessionState = undefined;
  this.playerPosition      = {x: 0, y: 0};

  this.screen.title = 'sshokoban';
  
  this.gameBox = blessed.box({
    top: 'center',
    left: 'center',
    width: 80,
    height: 24,
    border: {
      type: 'line'
    },
    style: {
      fg: 'white',
      border: {
        fg: '#f0f0f0'
      },
    }
  });
}

// Initialize key bindings
GameEngine.prototype.initializeBindings = function () {
  var this_ge = this;
  
  // Add key events to the following:
  // -- Exit --
  this.screen.key(['escape', 'q', 'C-c'], function(ch, key) {
    return process.exit(0);
  });
  // -- Arrow keys --
  this.screen.key('left', function(ch, key) {
    switch (this_ge.currentSessionState[this_ge.playerPosition.y][this_ge.playerPosition.x - 1]) {
      // If the new location is empty...
      case 'empty':
        this_ge.playerPosition.x--;
        this_ge.render();
        break;
    }
  });
  this.screen.key('right', function(ch, key) {
    switch (this_ge.currentSessionState[this_ge.playerPosition.y][this_ge.playerPosition.x + 1]) {
      // If the new location is empty...
      case 'empty':
        this_ge.playerPosition.x++;
        this_ge.render();
        break;
    }
  });
  this.screen.key('up', function(ch, key) {
    switch (this_ge.currentSessionState[this_ge.playerPosition.y - 1][this_ge.playerPosition.x]) {
      // If the new location is empty...
      case 'empty':
        this_ge.playerPosition.y--;
        this_ge.render();
        break;
    }
  });
  this.screen.key('down', function(ch, key) {
    switch (this_ge.currentSessionState[this_ge.playerPosition.y + 1][this_ge.playerPosition.x]) {
      // If the new location is empty...
      case 'empty':
        this_ge.playerPosition.y++;
        this_ge.render();
        break;
    }
  });
};

// Rendering
GameEngine.prototype.render = function () {
  this.screen.render();
  MapManager.render(this.currentMap, this.playerPosition, this.currentSessionState, this.gameBox, program);
};

GameEngine.prototype.resetPlayerPosition = function () {
  for (var y = 0; y < this.currentMap.height; y++) {
    for (var x = 0; x < this.currentMap.width; x++) {
      if (this.currentSessionState[y][x] == 'start') {
        this.currentSessionState[y][x] = 'empty';
        //TODO: Dirty
        return {x: x, y: y};
      }
    }
  }     
}

// Begin the game (After construction)
GameEngine.prototype.run = function () {
  this.initializeBindings();
  this.screen.append(this.gameBox);
  
  var this_ge = this; // Clone object
  
  // Load the first level
  MapManager.load('level1.tmx', function(err, map) {
    MapManager.validate(map);
    this_ge.currentMap = map;
    this_ge.currentSessionState = MapManager.internalize(map);
    this_ge.playerPosition = this_ge.resetPlayerPosition()
    this_ge.render();
  });
};

module.exports = GameEngine;
