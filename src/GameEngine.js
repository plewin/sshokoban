// Reference path generated by VS Code for "Type definitions for Node.js" file
/// <reference path="../typings/node/node.d.ts"/>

// Node.js modules
var MapManager = require('./MapManager.js');
var GameModel  = require('./GameModel.js');
var blessed    = require('blessed');
var program    = blessed.program();
var async      = require('async');

// GameEngine object constructor
function GameEngine() {
  // Add a blessed screen object
  this.screen = blessed.screen({
    autoPadding: true,
    fastCSR: true
  });

  this.gameModel = undefined;

  this.screen.title = 'sshokoban';
  
  this.bodyBox = blessed.box({
    top: 'center',
    left: 'center',
    width: 80,
    height: 24,
  });
  
  this.gameBox = blessed.box({
    width: 45,
    height: 24,
    border: {
      type: 'line'
    },
    style: {
      fg: 'white',
      border: {
        fg: '#f0f0f0'
      },
    }
  });

  this.chatBox = blessed.box({
    right: 0,
    width: 35,
    height: 24,
    scrollable: true,
    alwaysScroll: true,
    border: {
      type: 'line'
    },
  });
}

// Initialize key bindings
GameEngine.prototype.initializeBindings = function () {
  var this_ge = this;
  
  // Add key events to the following:
  // -- Exit --
  this.screen.key(['escape', 'q', 'C-c'], function(ch, key) {
    return process.exit(0);
  });

  // -- Arrow keys --
  function process_arrow_key (ch, key) {
	var direction = key.name;
    if (this_ge.gameModel.canMovePlayer(direction)) {
      this_ge.gameModel.movePlayer(direction);
    }
    this_ge.render();
  };

  this.screen.key('left',  process_arrow_key);
  this.screen.key('right', process_arrow_key);
  this.screen.key('up',    process_arrow_key);
  this.screen.key('down',  process_arrow_key);
};


// Rendering
GameEngine.prototype.render = function () {
  this.screen.render();
  MapManager.render(this.gameModel, this.gameBox, program);
};

GameEngine.prototype.playLevel = function (level, callback) {
  var this_ge = this;

  var on_objective_ok = function () {
    this_ge.chatBox.pushLine("One objective complete");
  };
  
  var on_game_over = function() {
    this_ge.chatBox.pushLine("Game over, thanks for playing");
    callback(null, null);
  };

  var on_ready = function () {
    this_ge.chatBox.pushLine("Now playing " + level);
    this_ge.render();
  }

  var on_map_loaded = function (err, map) {
    MapManager.validate(map);
	    
    this_ge.gameModel = new GameModel ();

    this_ge.gameModel.on('ready', on_ready);
    this_ge.gameModel.on('objective-ok', on_objective_ok);
    this_ge.gameModel.on('game-over', on_game_over);
  
    this_ge.gameModel.initialize(map, MapManager.internalize(map));
  }

  MapManager.load('level1.tmx', on_map_loaded);
};

// Begin the game (After construction)
GameEngine.prototype.run = function () {
  this.initializeBindings();
  
  this.bodyBox.append(this.gameBox);
  this.bodyBox.append(this.chatBox);
  
  this.screen.append(this.bodyBox);
  
  var self = this;
  async.series([
    function (callback) {
      self.playLevel('level1', callback);
    },
    function (callback) {
      self.playLevel('level2', callback);
    }, 
  ], function (err, results) {
	
  });

};

module.exports = GameEngine;
