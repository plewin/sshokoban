// Reference path generated by VS Code for "Type definitions for Node.js" file
/// <reference path="../typings/node/node.d.ts"/>

// Node.js modules
var MapManager = require('./MapManager.js');
var GameModel  = require('./GameModel.js');
var GameView   = require('./GameView.js');
var Datastore  = require('./Datastore.js');
var commands   = require('./commands.js');
var logger     = require('winston');
var async      = require('async');
var _          = require('lodash');
var Q          = require('q');

logger.level = 'warning';

function GameEngine() {
  this.gameModel = undefined;
  this.gameView  = new GameView();

  this.datastore = new Datastore();

  this.pendingCommands = [];
}

GameEngine.prototype.initializeBindings = function() {
  logger.info("Initializing bindings");
  
  var _self = this;

  this.gameView.bindKey(['escape', 'q', 'C-c'], function(ch, key) {
    return process.exit(0);
  });
  
  this.gameView.bindKey(['right', 'left'], function(ch, key) {
    if(_self.gameView.newGameButton.focused) {
      _self.gameView.sessionsList.focus();
    } else {
      _self.gameView.newGameButton.focus();
    }
  });
};

GameEngine.prototype.initializeGameBindings = function() {
  // needed to unbind
  this._processArrowKey = processArrowKey;

  this.gameView.bindKey(['left', 'up', 'right', 'down'], this._processArrowKey);
  
  var _this = this;

  function processArrowKey(ch, key) {
    logger.debug("Key %s pressed", key.name);
	var direction = key.name;
    if (_this.gameModel.canMovePlayer(direction)) {
      _this.pushCommand(new commands.MovePlayer(direction))
        .then(function() { _this.render(); });
    }
  };
};

GameEngine.prototype.pushCommand = function(command) {
  return this.datastore.pushCommand(command);
};

GameEngine.prototype.render = function() {
  logger.debug('Rendering');

  var command;
  while (command = this.pendingCommands.shift()) {
    command.execute(this.gameModel);
  }

  this.gameView.refresh();
  MapManager.render(this.gameModel, this.gameView.getGameViewport(), this.gameView.getCanvas());
};

GameEngine.prototype.joinLevel = function (sessionId, callback) {
  logger.info('Joining session %s', sessionId);
  var _this = this;
 
  this.gameView.bodyBox.show();

  MapManager.load('level1.tmx', createGameModel);

  function createGameModel(err, map) {
    MapManager.validate(map);
    _this.gameModel = new GameModel();

    _this.gameModel.on('ready', onReady);
    _this.gameModel.on('objective-ok', onObjectiveOk);
    _this.gameModel.on('game-over', onGameOver);
    
    _this.gameModel.initialize(map, MapManager.internalize(map));
  };

  function onObjectiveOk() {
    _this.gameView.pushLine("Sys: One objective complete");
  };
  
  function onGameOver() {
    _this.gameView.pushLine("Sys: Game over, thanks for playing");
  };

  function onReady() {
    _this.gameView.pushLine("Sys: Now watching");
    _this.render(); // render at least once

    _this.datastore.fetchPreviousCommands(sessionId)
      .then(function processPreviousCommands(cursor) {
        cursor.toArray().then(queueCommands).then(applyCommands);
      })
      .then(function subscribeNextCommands() {
        _this.datastore.registerCommandChanges(sessionId).then(registerCommandStream);
      });

    function queueCommands(reveivedCommands) {
      _.forEach(reveivedCommands, function(command) {
        _this.pendingCommands.push(commands.parse(command));
      });
    };
    
    function applyCommands() {
      _this.render();
    };
    
    function registerCommandStream(cursor) {
      cursor.each(function(err, row) {
        if (err) throw err;
        if(row['new_val'] != null && row['old_val'] == null) {
          _this.pendingCommands.push(commands.parse(row['new_val']));
          applyCommands();	
        }
      });
    };
  };
};

GameEngine.prototype.playLevel = function(level, callback) {
  logger.info('Playing level %s', level);
  var _this = this;

  this.gameView.bodyBox.show();
  this.initializeGameBindings();

  MapManager.load('level1.tmx', createGameModel);

  function createGameModel(err, map) {
    MapManager.validate(map);
    logger.debug('Map loaded successfully');
	    
    _this.gameModel = new GameModel();

    _this.gameModel.on('ready', onReady);
    _this.gameModel.on('objective-ok', onObjectiveOk);
    _this.gameModel.on('game-over', onGameOver);
	    
    _this.datastore.startCurrentSession().then(function(result) {
      _this.gameModel.initialize(map, MapManager.internalize(map));
    });
  };

  function onObjectiveOk() {
    _this.gameView.pushLine("Sys: One objective complete");
  };
	  
  function onGameOver() {
    _this.gameView.pushLine("Sys: Game over, thanks for playing");
	    
    _this.datastore.deleteCurrentSession().then(closeLevel);
  };

  function onReady() {
    _this.gameView.pushLine("Sys: Now playing " + level);
    _this.render(); // render at least once
	    
    _this.datastore.fetchPreviousCommands()
      .then(function processPreviousCommands(cursor) {
        cursor.toArray().then(queueCommands).then(applyCommands);
      })
      .then(function subscribeNextCommands() {
        _this.datastore.registerCommandChanges().then(registerCommandStream);
      });
	    
    function queueCommands(reveivedCommands) {
      _.forEach(reveivedCommands, function parseAndPushCommand(command) {
        _this.pendingCommands.push(commands.parse(command));
      });
    };
	    
    function applyCommands() {
      _this.render();
    };
	    
    function registerCommandStream(cursor) {
      cursor.each(function(err, row) {
        if (err) throw err;
        if(row['new_val'] != null && row['old_val'] == null) {
          _this.pendingCommands.push(commands.parse(row['new_val']));
          applyCommands();	
        }
      });
    };
  };

  function closeLevel() {
    _this.gameView.bodyBox.hide();
    _this.gameView.refresh();
    _this.gameView.unbindKey(['left', 'up', 'right', 'down'], this._processArrowKey);
    callback(null, null);
  };
};

GameEngine.prototype.displayHome = function(callback) {
  var _this = this;

  this.gameView.lobyBox.show();
  
  this.datastore.listSessions()
    .then(function resultsToArray(results) { return results.toArray(); })
    .then(function displayRows(rows) {
      var currentSessions = _.map(rows, rowToSessionDescription);

      _this.gameView.sessionsList.setItems(currentSessions);
      _this.gameView.refresh();
      
      _this.gameView.sessionsList.once('select', joinSession);
      _this.gameView.newGameButton.once('press', newGameSession);

      function joinSession(elem, index) {
        //TODO handle no current sessions case
      	_this.gameView.lobyBox.hide();
        callback(null, {type: 'join', sessionId: rows[index].id});
      }

      function newGameSession() {
        callback(null, {type: 'new-game'});
      }
    });
    
  function rowToSessionDescription(row) {
    var short_id = row.id.split('-')[0];   
    return short_id + " " + row.start.toISOString() + " player:" + row.player;
  }
};

GameEngine.prototype.run = function () {
  logger.debug('Running game engine');
  
  var _this = this;

  this.datastore.connect()
    .then(function() {
      _this.initializeBindings();
      _this.displayHome(function(err, ask) {
        if(ask.type == 'new-game') {
          _this.playLevel('level1', function() { console.log("finish"); });
        } else if(ask.type == 'join') {
          _this.joinLevel(ask.sessionId, function() { console.log("finish"); }); 
        }
      });
    });
};

module.exports = GameEngine;
